#입력받기
import sys
count = 0
r, c = map(int, sys.stdin.readline().rstrip("\n").split())
graph = []
for _ in range(r):
    graph.append(list(sys.stdin.readline().split("")))

#방문여부 만들기
visited =[[False] * c for _ in range(r)]


#dfs
def solve(x,y):
    if y == c -1 : #끝에 도달했다면
        return True

    dx = [-1,0,1] #대각 위 , 오른쪽, 대각 아래 순으로 탐색함
    for i in range(3):
        nx = x + dx[i]
        ny = y + 1
        if nx <0 or nx >= r or ny <0 or ny >= c : continue
        if visited[nx][ny] == False  and graph[nx][ny] == "." :#방문한 적 없다면
            visited[nx][ny] = True #방문처리
            if solve(nx,ny) == True :
                return True #끝까지 간다면. dfs에서 if문 자주 쓰임
    return False #대각선 위, 오른쪽, 대각 아래를 모두 탐색했는데도 끝이 안난다면 더이상 경로 없는것
                # 한번 탐색한 곳은 다시 갈필요가 없음
                
# 가능한 경로 찾기
ans = 0
for i in range(r):
    if graph[i][0] == ".":
        if solve(i,0):
            ans += 1
print(ans)




##문제의 쟁점 
- 파이프가 한 번 지나간 곳에 다른 파이프가 지나갈 수 없음
 => 방문 리스트를 생성해서 한 번 방문한 곳은 재탐색 하지 않도록 함
- 더 이상 파이프가 진행될 수 없다는 것을 알게 되도 반복 연산이 생김
 => 방문을 하고 다시 방문을 풀지 않는 것으로 이를 대체함
- 최대한 많은 파이프가 지나가기 위해선 오른쪽 대각선부터 파이프가 지나가야함

## 배운점
- 그리디 + dfs
- 방문을 했다가 풀지 않으면 이후 탐색에서도 방문 처리 돼서 두 번 이상 탐색하는 수 줄일 수 있음



